/* Deathray2 - An Avisynth plug-in filter for spatial/temporal non-local means de-noising.
 *
 * version 1.00
 *
 * Copyright 2015, Jawed Ashraf - Deathray@cupidity.f9.co.uk
 */

float GetWindowDistance(
    local       float   *target_cache,  // caches pixels around the 8x2 tile of target pixels
    local       float   *sample_cache,  // caches pixels around the 8x2 tile of sample pixels
    const       int2    sample,         // centre coordinates of sample window
    const       int     target,         // linear address of top-left of window in target cache
    constant    float   *g_gaussian) {  // 49 weights of gaussian kernel

    float distance = 0.f;
    int s_linear = mul24(sample.y - 3, 40) + sample.x - 3;
    int t_linear = target;
    int gaussian_position = 0;

    for (int y = -3; y < 4; ++y) {
        for (int x = -3; x < 4; ++x) {
            float diff = target_cache[t_linear++] - sample_cache[s_linear++];
            distance += g_gaussian[gaussian_position++] * (diff * diff);
        }
        t_linear += 9;
        s_linear += 33;
    }
    return distance;
}

// WriteAlpha
// Each work item writes an alpha weight/pixel pair to the region's alpha buffer
void WriteAlpha(
    const       uint    weight,         // weight/pixel pair to be written to region's alpha buffer
    const       int     region_base,    // base address within the region_alpha buffer for all alpha samples
    const       int     alpha_index,    // counter of weights generated by cooperator
    global      uint    *region_alpha) {// region's alpha weight/pixel pairs packed as uints

    // The region's alpha weights are organised as sets per pixel, with 8 weights per
    // pixel being generated concurrently by 8 cooperating work items.
    //
    // The sets are numbered according to the linearised coordinates of the pixel
    // within the region

    const int linear_address = (alpha_index << 3) + region_base;
    region_alpha[linear_address] = weight;
}

// WeightAnEighth
// Process one-eighth of the samples.
//
// The weight that will be assigned to the target pixel is also tracked.
void WeightAnEighth(
    read_only   image2d_t   plane,          // input plane
    const       float       h,              // strength of denoising
    const       int         sample_expand,  // factor to expand sample radius
    const       int         width,          // width in pixels
    const       int         height,         // height in pixels
    const       int2        top_left,       // coordinates of the top left corner of the region to be filtered
    const       int         skip_target,    // when set do not sample at the target pixel
    constant    float       *g_gaussian,    // 49 weights of gaussian kernel
    const       int         linear,         // process plane in linear space instead of gamma space
    local       float       *target_cache,  // caches pixels around the 8x1 strip of target pixels
    local       float       *sample_cache,  // caches pixels around the 8x1 strip of sample pixels
    const       int         alpha_set_size, // number of weight/pixel pairs per target pixel
    const       int         alpha_so_far,   // count of alpha samples generated so far (multi-frame support)
    global      uint        *region_alpha) {// region's alpha weight/pixel pairs packed as uints

    int2 target = GetTargetCoordinates(top_left);
    int radius = GetRadius(sample_expand);
    int eighth = GetEighthSequenceNumber();

    int2 set_max = GetSetMax(target, (int2)(width, height), radius);
    int2 sample = GetSampleStartCoordinates(target, radius, set_max, eighth);
    int2 sample_cache_base = GetSampleCacheBaseCoordinates(top_left, (int2)(width, height));
    PopulateSampleCache(plane, linear, sample_cache_base, sample_cache);

    int stride_count = GetStrideCount(radius);
    int stride = 0;

    // Determine linear address in target cache
    const int target_col_offset = get_local_id(1) & 7;
    const int target_row_offset = (get_local_id(1) >> 3) << 4;
    const int target_offset = target_col_offset + target_row_offset;

    // Determine base address in region_alpha buffer
    const int region_base = GetFilterRegionBaseAddress(width, alpha_set_size);

    int alpha_index = alpha_so_far;

    while (true) {
        int2 sample_offset = GetSampleOffset(sample, sample_cache_base);
        float euclidean_distance = GetWindowDistance(target_cache, sample_cache, sample_offset, target_offset, g_gaussian);
        uint sample_weight = (uint)(floor(16777215.f * exp(-euclidean_distance * h))) << 8;    
        uint sample_pixel = floor(255.f * sample_cache[mul24(sample_offset.y, 40) + sample_offset.x]);

        sample_weight |= sample_pixel;

        WriteAlpha(sample_weight, region_base, alpha_index, region_alpha);

        if (++stride == stride_count) {
            break;
        } else {
            sample = NextStride(target, sample, radius, set_max, skip_target);
            ++alpha_index;
        }
    }
}

